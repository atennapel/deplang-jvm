fac : Int -> Int := \n.
  let facR : Int -> Int -> Int := fix go n. \acc.
    if n < 2 then acc
    else go (n - 1) (acc * n) in
  facR n 1;

fold : {A : U0 Val} -> Int -> A -> (Int -> A -> A) -> A =
  \{A} n z s.
    `(let foldR : Int -> A -> A := fix go c. \acc.
      if c <= 0 then acc
      else go (c - 1) (s c acc) in
    foldR n z);

add : Int -> Int -> Int := \a b. fold a b (\_ n. n + 1);

main : Int -> Int := \_. add 1 2;
